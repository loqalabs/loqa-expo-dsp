{"version":3,"file":"extractFormants.js","sourceRoot":"","sources":["../src/extractFormants.ts"],"names":[],"mappings":"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","sourcesContent":["// extractFormants - Formant extraction API using LPC analysis\nimport LoqaAudioDspModule from './LoqaAudioDspModule';\nimport { NativeModuleError } from './errors';\nimport type { FormantExtractionOptions, FormantsResult } from './types';\nimport { logDebug } from './utils';\nimport { validateAudioBuffer, validateSampleRate } from './validation';\n\n/**\n * Extracts formants (F1, F2, F3) using LPC analysis\n *\n * This function performs Linear Predictive Coding (LPC) analysis to extract\n * the first three formant frequencies from audio data. Formants are resonant\n * frequencies of the vocal tract and are essential for vowel identification\n * and speech analysis.\n *\n * @param audioBuffer - Audio samples (Float32Array or number[])\n * @param sampleRate - Sample rate in Hz (8000-48000)\n * @param options - Formant extraction options (lpcOrder)\n * @returns Promise resolving to formants result with F1, F2, F3 and bandwidths\n * @throws ValidationError if buffer or sample rate are invalid\n * @throws NativeModuleError if native computation fails\n *\n * @example\n * ```typescript\n * const audioData = new Float32Array(2048);\n * // ... fill with voiced audio samples ...\n *\n * const result = await extractFormants(audioData, 44100, {\n *   lpcOrder: 14  // Optional: LPC order (defaults to sampleRate/1000 + 2)\n * });\n *\n * console.log(`F1: ${result.f1} Hz`);\n * console.log(`F2: ${result.f2} Hz`);\n * console.log(`F3: ${result.f3} Hz`);\n * console.log(`Bandwidths:`, result.bandwidths);\n * ```\n */\nexport async function extractFormants(\n  audioBuffer: Float32Array | number[],\n  sampleRate: number,\n  options?: Partial<FormantExtractionOptions>\n): Promise<FormantsResult> {\n  // Step 1: Validate audio buffer and sample rate\n  logDebug('extractFormants called', {\n    bufferLength: audioBuffer.length,\n    bufferType: audioBuffer instanceof Float32Array ? 'Float32Array' : 'number[]',\n    sampleRate,\n    options,\n  });\n\n  validateAudioBuffer(audioBuffer);\n  validateSampleRate(sampleRate);\n\n  // Step 2: Calculate default LPC order based on sample rate\n  // Formula: lpcOrder = (sampleRate / 1000) + 2\n  // This provides appropriate resolution for formant analysis\n  const defaultLpcOrder = Math.floor(sampleRate / 1000) + 2;\n  const lpcOrder = options?.lpcOrder ?? defaultLpcOrder;\n\n  // Validate LPC order is positive\n  if (lpcOrder <= 0) {\n    throw new NativeModuleError('LPC order must be positive', {\n      lpcOrder,\n    });\n  }\n\n  // Step 3: Convert to number[] for React Native bridge\n  // React Native bridge requires plain arrays, not typed arrays\n  const bufferArray: number[] =\n    audioBuffer instanceof Float32Array ? Array.from(audioBuffer) : audioBuffer;\n\n  logDebug('Calling native module for formant extraction', {\n    sampleRate,\n    lpcOrder,\n    defaultLpcOrder,\n  });\n\n  try {\n    // Step 4: Call native module\n    const nativeResult = await LoqaAudioDspModule.extractFormants(bufferArray, sampleRate, {\n      lpcOrder,\n    });\n\n    logDebug('Native module returned formants result', {\n      f1: nativeResult.f1,\n      f2: nativeResult.f2,\n      f3: nativeResult.f3,\n      hasBandwidths: !!nativeResult.bandwidths,\n    });\n\n    // Step 5: Convert result to FormantsResult type\n    // Native module returns dictionary/map, convert to proper TypeScript type\n    const result: FormantsResult = {\n      f1: nativeResult.f1,\n      f2: nativeResult.f2,\n      f3: nativeResult.f3,\n      bandwidths: {\n        f1: nativeResult.bandwidths.f1,\n        f2: nativeResult.bandwidths.f2,\n        f3: nativeResult.bandwidths.f3,\n      },\n    };\n\n    logDebug('extractFormants completed successfully', {\n      f1: result.f1,\n      f2: result.f2,\n      f3: result.f3,\n    });\n\n    return result;\n  } catch (error: unknown) {\n    // Step 6: Wrap native errors in NativeModuleError with context\n    const errorMessage = error instanceof Error ? error.message : String(error);\n\n    logDebug('extractFormants failed', {\n      error: errorMessage,\n      sampleRate,\n      lpcOrder,\n      bufferLength: audioBuffer.length,\n    });\n\n    throw new NativeModuleError(`Formant extraction failed: ${errorMessage}`, {\n      originalError: error,\n      sampleRate,\n      lpcOrder,\n      bufferLength: audioBuffer.length,\n    });\n  }\n}\n"]}